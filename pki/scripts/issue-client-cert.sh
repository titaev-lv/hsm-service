#!/bin/bash
#
# Issue Client Certificate
#
# Usage: ./issue-client-cert.sh <cn> <ou>
# Example: ./issue-client-cert.sh trading-service-1 Trading
#
# This script generates a client certificate with the specified OU
# and updates the certificate inventory.

set -e

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
NC='\033[0m' # No Color

# Script directory
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
PKI_DIR="$(dirname "$SCRIPT_DIR")"
CA_DIR="$PKI_DIR/ca"
CLIENT_DIR="$PKI_DIR/client"
INVENTORY_FILE="$PKI_DIR/inventory.yaml"

# Valid OUs (from TECHNICAL_SPEC.md)
VALID_OUS=("Trading" "2FA" "Database" "Admin")

# Check arguments
if [ $# -lt 2 ]; then
    echo -e "${RED}Error: Missing arguments${NC}"
    echo "Usage: $0 <cn> <ou>"
    echo ""
    echo "Arguments:"
    echo "  cn    Common Name (e.g., trading-service-1)"
    echo "  ou    Organizational Unit (Trading | 2FA | Database | Admin)"
    echo ""
    echo "Valid OUs:"
    echo "  Trading  - For trading services (context: exchange-key)"
    echo "  2FA      - For 2FA services (context: 2fa)"
    echo "  Database - For MySQL/ClickHouse clients"
    echo "  Admin    - For administrative access (future)"
    echo ""
    echo "Example:"
    echo "  $0 trading-service-1 Trading"
    echo "  $0 web-2fa-service 2FA"
    exit 1
fi

CN="$1"
OU="$2"

# Validate OU
if [[ ! " ${VALID_OUS[@]} " =~ " ${OU} " ]]; then
    echo -e "${RED}Error: Invalid OU: $OU${NC}"
    echo "Valid OUs: ${VALID_OUS[*]}"
    exit 1
fi

# Validate CA exists
if [ ! -f "$CA_DIR/ca.crt" ] || [ ! -f "$CA_DIR/ca.key" ]; then
    echo -e "${RED}Error: CA certificate or key not found in $CA_DIR${NC}"
    echo "Please ensure ca.crt and ca.key exist in $CA_DIR"
    exit 1
fi

# Create output directory if not exists
mkdir -p "$CLIENT_DIR"

# File paths
KEY_FILE="$CLIENT_DIR/${CN}.key"
CSR_FILE="$CLIENT_DIR/${CN}.csr"
CERT_FILE="$CLIENT_DIR/${CN}.crt"
EXT_FILE="$CLIENT_DIR/${CN}.ext"

# Check if certificate already exists
if [ -f "$CERT_FILE" ]; then
    echo -e "${YELLOW}Warning: Certificate for $CN already exists${NC}"
    read -p "Overwrite? (y/N): " -n 1 -r
    echo
    if [[ ! $REPLY =~ ^[Yy]$ ]]; then
        echo "Aborted."
        exit 0
    fi
fi

echo -e "${GREEN}Generating client certificate for: $CN (OU=$OU)${NC}"

# 1. Generate private key (RSA 4096)
echo "→ Generating RSA 4096 private key..."
openssl genrsa -out "$KEY_FILE" 4096 2>/dev/null
chmod 600 "$KEY_FILE"
echo "  ✓ Private key saved to $KEY_FILE"

# 2. Create CSR with OU
echo "→ Creating Certificate Signing Request..."
SUBJECT="/C=RU/ST=Moscow/L=Moscow/O=Private/OU=${OU}/CN=${CN}"

openssl req -new \
    -key "$KEY_FILE" \
    -out "$CSR_FILE" \
    -subj "$SUBJECT" 2>/dev/null

echo "  ✓ CSR created with subject: $SUBJECT"

# 3. Create extension file for client cert
echo "→ Creating extension file..."
cat > "$EXT_FILE" <<EOF
keyUsage = critical, digitalSignature
extendedKeyUsage = clientAuth
EOF

echo "  ✓ Extension configuration created"

# 4. Sign certificate with CA
echo "→ Signing certificate with CA..."
openssl x509 -req \
    -in "$CSR_FILE" \
    -CA "$CA_DIR/ca.crt" \
    -CAkey "$CA_DIR/ca.key" \
    -CAcreateserial \
    -out "$CERT_FILE" \
    -days 365 \
    -sha256 \
    -extfile "$EXT_FILE" 2>/dev/null

echo "  ✓ Certificate signed and saved to $CERT_FILE"

# 5. Clean up temporary files
rm -f "$CSR_FILE" "$EXT_FILE"

# 6. Verify certificate
echo "→ Verifying certificate..."
if openssl verify -CAfile "$CA_DIR/ca.crt" "$CERT_FILE" >/dev/null 2>&1; then
    echo -e "  ${GREEN}✓ Certificate verification successful${NC}"
else
    echo -e "  ${RED}✗ Certificate verification failed${NC}"
    exit 1
fi

# 7. Extract certificate information
SERIAL=$(openssl x509 -in "$CERT_FILE" -noout -serial | cut -d'=' -f2)
NOT_BEFORE=$(openssl x509 -in "$CERT_FILE" -noout -startdate | cut -d'=' -f2)
NOT_AFTER=$(openssl x509 -in "$CERT_FILE" -noout -enddate | cut -d'=' -f2)
ISSUED_DATE=$(date -d "$NOT_BEFORE" +%Y-%m-%d 2>/dev/null || date -j -f "%b %d %T %Y %Z" "$NOT_BEFORE" +%Y-%m-%d)
EXPIRES_DATE=$(date -d "$NOT_AFTER" +%Y-%m-%d 2>/dev/null || date -j -f "%b %d %T %Y %Z" "$NOT_AFTER" +%Y-%m-%d)

# Determine access contexts based on OU
ACCESS_CONTEXTS=""
case "$OU" in
    "Trading")
        ACCESS_CONTEXTS="[exchange-key]"
        ;;
    "2FA")
        ACCESS_CONTEXTS="[2fa]"
        ;;
    "Database")
        ACCESS_CONTEXTS="[]"
        ;;
    "Admin")
        ACCESS_CONTEXTS="[admin]"
        ;;
esac

# 8. Update inventory
echo "→ Updating inventory..."
if [ ! -f "$INVENTORY_FILE" ]; then
    cat > "$INVENTORY_FILE" <<EOF
# Certificate Inventory
# Auto-generated by PKI scripts
certificates:
  servers: []
  clients: []
EOF
fi

# Create temporary Python script for YAML manipulation
python3 - <<EOF
import yaml
import sys

inventory_file = "$INVENTORY_FILE"

# Load existing inventory
try:
    with open(inventory_file, 'r') as f:
        inventory = yaml.safe_load(f) or {}
except:
    inventory = {}

if 'certificates' not in inventory:
    inventory['certificates'] = {}
if 'clients' not in inventory['certificates']:
    inventory['certificates']['clients'] = []

# Parse access contexts
access_str = "$ACCESS_CONTEXTS"
if access_str == "[]":
    access_contexts = []
else:
    # Remove brackets and parse
    access_str = access_str.strip('[]')
    access_contexts = [ctx.strip() for ctx in access_str.split(',') if ctx.strip()]

# Create new certificate entry
new_cert = {
    'cn': '$CN',
    'ou': '$OU',
    'issued': '$ISSUED_DATE',
    'expires': '$EXPIRES_DATE',
    'serial': '$SERIAL',
    'access_contexts': access_contexts if access_contexts else None,
    'file': 'client/$CN'
}

# Remove None values
new_cert = {k: v for k, v in new_cert.items() if v is not None}

# Remove existing entry with same CN if exists
inventory['certificates']['clients'] = [
    cert for cert in inventory['certificates']['clients'] 
    if cert.get('cn') != '$CN'
]

# Add new entry
inventory['certificates']['clients'].append(new_cert)

# Sort by CN
inventory['certificates']['clients'].sort(key=lambda x: x.get('cn', ''))

# Write back
with open(inventory_file, 'w') as f:
    yaml.dump(inventory, f, default_flow_style=False, sort_keys=False)

print("  ✓ Inventory updated")
EOF

# 9. Display certificate info
echo ""
echo -e "${GREEN}═══════════════════════════════════════════════════════${NC}"
echo -e "${GREEN}Client Certificate Generated Successfully${NC}"
echo -e "${GREEN}═══════════════════════════════════════════════════════${NC}"
echo "Common Name:    $CN"
echo "Subject:        $SUBJECT"
echo "Serial:         $SERIAL"
echo "Issued:         $ISSUED_DATE"
echo "Expires:        $EXPIRES_DATE"

# Display access information based on OU
case "$OU" in
    "Trading")
        echo -e "${YELLOW}Access Rights:${NC}  Can use context: exchange-key"
        echo "                (Encrypt/decrypt DEKs for trading services)"
        ;;
    "2FA")
        echo -e "${YELLOW}Access Rights:${NC}  Can use context: 2fa"
        echo "                (Encrypt/decrypt 2FA secrets)"
        ;;
    "Database")
        echo -e "${YELLOW}Access Rights:${NC}  Database client only (MySQL/ClickHouse)"
        echo "                (No HSM service access)"
        ;;
    "Admin")
        echo -e "${YELLOW}Access Rights:${NC}  Administrative access (future)"
        ;;
esac

echo ""
echo "Files created:"
echo "  Certificate:  $CERT_FILE"
echo "  Private Key:  $KEY_FILE"
echo ""
echo -e "${YELLOW}Next steps:${NC}"
echo "1. Copy certificate and key to your client service"
echo "2. Configure mTLS client with these files"
echo "3. Ensure private key has restricted permissions (0600)"
echo ""
echo -e "${YELLOW}Testing connection:${NC}"
echo "  curl -X POST https://hsm-service.local:8443/encrypt \\"
echo "    --cert $CERT_FILE \\"
echo "    --key $KEY_FILE \\"
echo "    --cacert $CA_DIR/ca.crt \\"
echo "    -H 'Content-Type: application/json' \\"
echo "    -d '{\"context\":\"exchange-key\",\"plaintext\":\"SGVsbG8=\"}'"
echo -e "${GREEN}═══════════════════════════════════════════════════════${NC}"
